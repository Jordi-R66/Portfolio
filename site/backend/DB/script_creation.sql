CREATE EXTENSION IF NOT EXISTS pgcrypto;

drop table if exists public.messagesFormulaire CASCADE;
drop table if exists public.codesStatutSms CASCADE;
drop table if exists public.auth_codes CASCADE;
drop table if exists public.users CASCADE;
drop table if exists public.sms CASCADE;

create table public.messagesFormulaire (
	idMessage			INTEGER generated by default as identity primary key,
	ipMessage			VARCHAR(32) not null,
	timestampMessage	BIGINT not null default 0,
	sujetMessage		VARCHAR(64) not null,
	corpsMessage		VARCHAR(240) not null,
	telephone			VARCHAR(20) not null default '',
	email				VARCHAR(254) not null default '',
	lu					BOOLEAN not null default FALSE
);

create table public.codesStatutSms (
	codeStatut	INTEGER PRIMARY KEY,
	codeDesc	VARCHAR(20) NOT NULL
);

create table public.sms (
	idSms		INTEGER generated by default as identity primary key,
	timeMsg		BIGINT not null default 0,
	content		VARCHAR(140) not null default '',
	codeStatut	INTEGER NOT NULL,

	CONSTRAINT fk_code_statut FOREIGN KEY (codeStatut) REFERENCES public.codesStatutSms ON DELETE CASCADE
);

create table public.users (
	userId		INTEGER generated by default as identity primary key,
	username	VARCHAR(32) UNIQUE not null,
	passHash	TEXT not null,
	lastConn	TIMESTAMPTZ not null
);

create table public.auth_codes (
	userId		INTEGER NOT NULL,
	codeUUID	UUID PRIMARY KEY DEFAULT gen_random_uuid(),
	expiration	TIMESTAMPTZ NOT NULL,

	CONSTRAINT fk_userId FOREIGN KEY (userId) REFERENCES public.users ON DELETE CASCADE
);

CREATE OR REPLACE FUNCTION prevent_modifications()
RETURNS TRIGGER AS $$
BEGIN
	RAISE EXCEPTION 'INTERDIT : Les modifications (UPDATE) sont bloquées sur cette table. Supprimez et recréez la ligne si nécessaire.';
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_no_update
	BEFORE UPDATE ON public.auth_codes -- Remplace par le nom de ta table
	FOR EACH ROW
	EXECUTE FUNCTION prevent_modifications();

CREATE OR REPLACE FUNCTION public.creer_utilisateur(
	p_username TEXT, 
	p_password_clair TEXT
) RETURNS INTEGER AS $$
DECLARE
	v_new_id INTEGER;
BEGIN
	INSERT INTO public.users (username, passHash, lastConn)
	VALUES (
		p_username,
		-- Hachage avec Blowfish (Bcrypt), coût 10
		crypt(p_password_clair, gen_salt('bf', 10)),
		NOW()
	)
	RETURNING userId INTO v_new_id;

	RETURN v_new_id;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION public.changer_mdp(
	p_username TEXT, 
	p_nouveau_mdp TEXT
) RETURNS VOID AS $$
BEGIN
	UPDATE public.users
	SET passHash = crypt(p_nouveau_mdp, gen_salt('bf', 10))
	WHERE username = p_username;

	IF NOT FOUND THEN
		RAISE EXCEPTION 'Utilisateur % introuvable', p_username;
	END IF;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION public.admin_reset_password(
	p_username TEXT, 
	p_new_password TEXT
) RETURNS VOID AS $$
BEGIN
	UPDATE public.users
	SET passHash = crypt(p_new_password, gen_salt('bf', 10))
	WHERE username = p_username;

	-- Petite sécurité : lève une erreur si l'utilisateur n'existe pas
	IF NOT FOUND THEN
		RAISE EXCEPTION 'Utilisateur % introuvable', p_username;
	END IF;
END;
$$ LANGUAGE plpgsql;

INSERT INTO public.codesStatutSms (codeStatut, codeDesc) VALUES (200, 'Succès');
INSERT INTO public.codesStatutSms (codeStatut, codeDesc) VALUES (400, 'Paramètre manquant');
INSERT INTO public.codesStatutSms (codeStatut, codeDesc) VALUES (402, 'Rate limit');
INSERT INTO public.codesStatutSms (codeStatut, codeDesc) VALUES (403, 'Service désactivé');
INSERT INTO public.codesStatutSms (codeStatut, codeDesc) VALUES (500, 'Erreur serveur');
